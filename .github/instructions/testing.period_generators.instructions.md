---
applyTo: 'test/period_generators/**/*_test.dart'
---

# Period Generator Testing Standards

Testing standards specific to PeriodGenerator classes in the due_date library.

## Test Structure Extensions for PeriodGenerator Classes

In addition to the standard test structure, PeriodGenerator classes must include these specific test groups:

```dart
group('of', () {
  // Test core period generation from DateTime inputs
  // Test with start, middle, and end of periods
});

group('before', () {
  // Test navigation to previous periods
});

group('after', () {
  // Test navigation to next periods
});

group('sub-periods', () {
  // Test sub-period collections (e.g., hours in day, days in month)
});

group('Time component preservation', () {
  // Test UTC vs local DateTime handling
});

test('fits generator', () {
  // Test fitsGenerator method with valid periods
});

test('does not fit generator', () {
  // Test fitsGenerator method with invalid periods
});
```

## Constructor Testing

Test generator constructor validation:

```dart
group('Constructor', () {
  test('Creates generator instance', () {
    expect(const Generator(), isNotNull);
  });
  
  // For generators with parameters (e.g., WeekGenerator)
  test('Constructor with parameters', () {
    expect(const WeekGenerator(weekStart: DateTime.tuesday), isNotNull);
  });
});
```

## Primary Method Testing - `of`

Test the core `of` method that generates periods from dates:

```dart
group('of', () {
  test('Start of period', () {
    final period = generator.of(DateTime(2020));
    final expected = Period(
      start: DateTime(2020),
      end: DateTime(2020, 1, 1, 23, 59, 59, 999, 999),
    );
    expect(period, equals(expected));
  });
  
  test('End of period', () {
    final period = generator.of(DateTime(2020, 1, 1, 23, 59, 59, 999, 999));
    expect(period, equals(expected));
  });
  
  test('Middle of period', () {
    final period = generator.of(DateTime(2020, 1, 1, 12, 30));
    expect(period, equals(expected));
  });
});
```

## Navigation Method Testing - `before` and `after`

Test period navigation methods:

```dart
group('before', () {
  test('Start of period', () {
    final period = generator.of(DateTime(2020));
    final previous = generator.before(period);
    final expected = Period(
      start: DateTime(2019, 12, 31),
      end: DateTime(2019, 12, 31, 23, 59, 59, 999, 999),
    );
    expect(previous, equals(expected));
  });
  
  test('End of period', () {
    final period = generator.of(DateTime(2020, 1, 1, 23, 59, 59, 999, 999));
    final previous = generator.before(period);
    expect(previous, equals(expected));
  });
});

group('after', () {
  test('Start of period', () {
    final period = generator.of(DateTime(2020));
    final next = generator.after(period);
    final expected = Period(
      start: DateTime(2020, 1, 2),
      end: DateTime(2020, 1, 2, 23, 59, 59, 999, 999),
    );
    expect(next, equals(expected));
  });
  
  test('End of period', () {
    final period = generator.of(DateTime(2020, 1, 1, 23, 59, 59, 999, 999));
    final next = generator.after(period);
    expect(next, equals(expected));
  });
});
```

## Sub-period Collection Testing

Test collections of sub-periods generated by periods:

```dart
group('sub-periods', () {
  final period = generator.of(DateTime(2020));
  final subPeriods = period.subPeriods; // e.g., hours for day, minutes for hour
  
  test('type', () {
    expect(subPeriods, isA<List<SubPeriodType>>());
  });
  
  test('length', () {
    expect(subPeriods.length, equals(expectedCount));
  });
  
  test('Start of period', () {
    final firstSub = subGenerator.of(DateTime(2020));
    expect(subPeriods.first, equals(firstSub));
  });
  
  test('End of period', () {
    final lastSub = subGenerator.of(DateTime(2020, 1, 1, 23, 59, 59, 999, 999));
    expect(subPeriods.last, equals(lastSub));
  });
});
```

## Generator Validation Testing - `fitsGenerator`

Test the `fitsGenerator` method:

```dart
test('fits generator', () {
  final period = Period(
    start: DateTime(2020),
    end: DateTime(2020, 1, 1, 23, 59, 59, 999, 999),
  );
  expect(generator.fitsGenerator(period), isTrue);
});

test('does not fit generator', () {
  final period = Period(
    start: DateTime(2020),
    end: DateTime(2020, 1, 2), // Wrong end date
  );
  expect(generator.fitsGenerator(period), isFalse);
});
```

## Time Component Preservation Testing

Test that generators preserve time components correctly:

```dart
group('Time component preservation', () {
  test('Maintains time components in local DateTime', () {
    final input = DateTime(2020, 1, 15, 10, 30, 45, 123, 456);
    final period = generator.of(input);
    expect(period.start.isUtc, isFalse);
    expect(period.end.isUtc, isFalse);
  });
  
  test('Maintains time components in UTC DateTime', () {
    final input = DateTime.utc(2020, 1, 15, 10, 30, 45, 123, 456);
    final period = generator.of(input);
    expect(period.start.isUtc, isTrue);
    expect(period.end.isUtc, isTrue);
  });
});
```

## Calendar Edge Cases

Test boundary conditions and special calendar scenarios:

```dart
group('Edge cases', () {
  test('Leap year February', () {
    final period = monthGenerator.of(DateTime(2020, 2, 15));
    expect(period.end.day, equals(29));
  });
  
  test('Non-leap year February', () {
    final period = monthGenerator.of(DateTime(2021, 2, 15));
    expect(period.end.day, equals(28));
  });
  
  test('Month with 30 days', () {
    final period = monthGenerator.of(DateTime(2020, 4, 15));
    expect(period.end.day, equals(30));
  });
  
  test('Month with 31 days', () {
    final period = monthGenerator.of(DateTime(2020, 1, 15));
    expect(period.end.day, equals(31));
  });
  
  test('Year boundary crossing', () {
    final period = dayGenerator.of(DateTime(2019, 12, 31));
    final next = dayGenerator.after(period);
    expect(next.start.year, equals(2020));
  });
});
```

## Required Coverage for PeriodGenerator Classes

Every period generator class test must cover:

1. **Constructor testing** - Instance creation and parameter validation
2. **Core `of` method** - Period generation from various DateTime inputs
3. **Navigation methods** - `before` and `after` functionality  
4. **Sub-period collections** - Type, count, start/end alignment, and continuity
5. **Generator validation** - `fitsGenerator` method with valid and invalid periods
6. **Equality behavior** - Object equality and hashCode consistency
7. **Edge cases** - Calendar boundaries, leap years, month variations, year crossings
8. **Time preservation** - Local vs UTC DateTime handling
9. **Generator-specific behavior** - Week starts, fortnight divisions, multi-month periods
10. **Explicit date calculations** - Concrete input-to-output verification
